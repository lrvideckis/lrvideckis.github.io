<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Segment Tree Indexing</title>
        <link rel="stylesheet" href="/style.css">
        <link rel="stylesheet" href="/highlight/styles/github.min.css">
        <script src="/highlight/highlight.min.js"></script>
        <script>
            document.addEventListener('DOMContentLoaded', (event) => {
                document.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightBlock(block);
                });
            });
        </script>
    </head>
    <body>
        <script type="text/javascript" language="javascript" src="/navagation_bar.js"></script>
        <div class="body">
            <div class="heading">
                <h1 class="main_title">Segment Tree Indexing and Tree Traversals</h1>
                <h2 class="blog_date">2023 September 1</h2>
            </div>
            <br>
            <div class="main_content">
                <h3>Background</h3>
                <p>
For background about what a segment tree is, I recommend the
                <a href="https://cp-algorithms.com/data_structures/segment_tree.html">CP algorithms article</a>.
                </p>
                <hr>
                <p>
                The
<a href="https://cp-algorithms.com/data_structures/segment_tree.html#implementation">standard implementation</a>
of a segment tree uses an array <code>t</code> of size <code>4*n</code>.
                This blog discusses 3 different ways how to index the
                nodes in a segment tree to achieve (optimal) <code>2*n-1</code> memory.
                </p>
                <details>
                    <summary>why is <code>2*n-1</code> optimal?</summary>
                    <ul>
                        <li>A segment tree has <code>n</code> leaf nodes; 1 for each of the <code>n</code> elements in the array</li>
                        <li>A segment tree is a <a href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">full binary tree</a>; each internal node has exactly 2 children. Thus there are <code>n-1</code> internal nodes.</li>
                        <img src="bst_leaf_vs_internal_nodes.png" alt="leaf versus internal" style="width:540px;height:auto;">
                    </ul>
                </details>
                <p>
                Let's look at the "standard" implementation:
                </p>

                <details>
                    <summary>code</summary>
                    <pre><code class="language-cpp">
const int MAXN = 500'000;
int n;
long long t[4*MAXN];

void build(int a[], int tl=0, int tr=n, int v=1) {
    if (tr - tl == 1) {
        t[v] = a[tl];
    } else {
        int tm = (tl+tr)/2;
        build(a, tl, tm, 2*v);
        build(a, tm, tr, 2*v+1);
        t[v] = t[2*v] + t[2*v+1];
    }
}

long long query(int l, int r, int tl=0, int tr=n, int v=1) {
    if (r <= tl || tr <= l) return 0LL;
    if (l <= tl && tr <= r) return t[v];
    int tm = (tl+tr)/2;
    return query(l, r, tl, tm, 2*v)
         + query(l, r, tm, tr, 2*v+1);
}

void update(int pos, int val, int tl=0, int tr=n, int v=1) {
    if (tr - tl == 1) {
        t[v] += val;
    } else {
        int tm = (tl+tr)/2;
        if (pos < tm)
            update(pos, val, tl, tm, 2*v);
        else
            update(pos, val, tm, tr, 2*v+1);
        t[v] = t[2*v] + t[2*v+1];
    }
}
                    </code></pre>
                </details>
                <p>
                Notes:
                </p>
                <ul>
                    <li>Update: do <code>a[pos] += val</code></li>
                    <li>Query: calculate <code>a[l] + a[l+1] + ... + a[r-1]</code></li>
                    <li>The node with index <code>v</code> has inclusive-exclusive range <code>[tl, tr)</code></li>
                    <li>Range <code>[tl, tr)</code> splits into ranges <code>[tl, tm)</code> and <code>[tm, tr)</code></li>
                    <li>Node <code>v</code> has children <code>2*v</code>, <code>2*v+1</code>, and parent <code>v/2</code>. This is known as the <a href="https://en.algorithmica.org/hpc/data-structures/binary-search/#eytzinger-layout">Eytzinger Layout</a>.</li>
                </ul>
                <hr>
                <p>
                Our approach to optimize the memory will be to take some traversial of the tree, and index the nodes <code>0,1,...,2*n-2</code> in order of this traversial. Now there many ways to traverse a binary tree:
                </p>
                <ul>
                    <li>Pre order (dfs)</li>
                    <li>In order (dfs)</li>
                    <li>Post order (dfs)</li>
                    <li>Level order (bfs)</li>
                </ul>
                <p>But pre order and post order are symmetrical, so I'll only focus on pre order.</p>
                <h3>Pre Order</h3>
                <p>First, the <a
                    href="https://cp-algorithms.com/data_structures/segment_tree.html#memory-efficient-implementation">source</a>
                for the idea for this approach. Now, an example of indexing the
                pre-order of a full binary tree
                <code>0,1,2,...</code></p>
                <img src="bst_pre_order.png" alt="bst pre order" style="width:540px;height:auto;">
                <p>
                Observations:
                </p>
                <ul>
                    <li>The root is <code>0</code></li>
                    <li>A node <code>v</code>'s left child has index <code>v+1</code></li>
                    <li>A node <code>v</code>'s right child has index <code>v+1+(size of left subtree)</code></li>
                    <li>In a segment tree, a node with range <code>[tl, tr)</code> has subtree size = <code>2*(tr-tl)-1</code>
                                <details>
                                    <summary>how to derive this</summary>
                                    <ol>
                                        <li>range <code>[tl, tr)</code> contains <code>tr-tl</code> leaf nodes representing <code>a[tl], a[tl+1], ..., a[tr-1]</code></li>
                                        <li>In a full binary tree, any subtree with <code>k</code> leaves will have <code>k-1</code> internal nodes</li>
                                    </ol>
                                </details>

                    </li>
                </ul>
                <p>So we can code segment trees with <code>2*n-1</code> memory like:</p>

                <details>
                    <summary>code</summary>
                    <pre><code class="language-cpp">
const int MAXN = 500'000;
int n;
long long t[2*MAXN-1];

void build(int a[], int tl=0, int tr=n, int v=0) {
    if (tr - tl == 1) {
        t[v] = a[tl];
    } else {
        int tm = (tl+tr)/2;
        build(a, tl, tm, v+1);
        build(a, tm, tr, v+2*(tm-tl));
        t[v] = t[v+1] + t[v+2*(tm-tl)];
    }
}

long long query(int l, int r, int tl=0, int tr=n, int v=0) {
    if (r <= tl || tr <= l) return 0LL;
    if (l <= tl && tr <= r) return t[v];
    int tm = (tl+tr)/2;
    return query(l, r, tl, tm, v+1)
         + query(l, r, tm, tr, v+2*(tm-tl));
}

void update(int pos, int val, int tl=0, int tr=n, int v=0) {
    if (tr - tl == 1) {
        t[v] += val;
    } else {
        int tm = (tl+tr)/2;
        if (pos < tm)
            update(pos, val, tl, tm, v+1);
        else
            update(pos, val, tm, tr, v+2*(tm-tl));
        t[v] = t[v+1] + t[v+2*(tm-tl)];
    }
}
                    </code></pre>
                </details>
                <h3>Level Order</h3>
                <p>Let's revisit the "standard" max-heap implementation:</p>
                <ul>
                    <li>It's a <a href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">complete binary tree</a></li>
                    <li>It uses the <a href="https://en.algorithmica.org/hpc/data-structures/binary-search/#eytzinger-layout">Eytzinger Layout</a> (in our case, shifted down by one), thus:
                        <ul>
                            <li>The root is <code>0</code></li>
                            <li>node <code>v</code>'s left child has index <code>2*v+1</code>, right child has index <code>2*v+2</code>
                                <details>
                                    <summary>how to derive right child formula</summary>
                                    <ol>
                                        <li>"shift" up 1</li>
                                        <li>apply right child formula</li>
                                        <li>"shift" down 1</li>
                                    </ol>
                                    like: <code>(2*(v+1)+1)-1</code>
                                </details>
                            </li>
                            <li>the <code>k</code> nodes have distinct indexes in range <code>[0, k-1]</code> (this is only true because it's complete)</li>
                        </ul>
                    </li>
                </ul>
                <img src="bst_level_order.png" alt="bst level order" style="width:540px;height:auto;">
                <p>Let's try to make this indexing layout work for segment trees. But there's a problem. Usually for segtrees, each node <code>v</code> has:</p>
                <ol>
                    <li>range <code>[tl, tr)</code></li>
                    <li>subtree size <code>2*(tr-tl)-1</code></li>
                    <li>midpoint <code>(tl+tr)/2</code></li>
                </ol>
                <details>
                    <summary>Do you see the problem?</summary>
                    <ol>
                        <li>In a segtree, the range is split in half (<code>tm=(tl+tr)/2</code>), so <code>v</code>'s left, right subtree sizes are off-by-2</li>
                        <li>But for a complete binary tree, the left/right subtree sizes aren't necessarily off-by-2</li>
                    </ol>
                </details>
                <p>So we have to calculate the midpoint differently. It turns out the correct way to calculate it is:</p>

                <pre><code class="language-cpp">
int split(int tl, int tr) {
    int pow_2 = 1 << __lg(tr-tl);
    return min(tl+pow_2, tr-pow_2/2);
}
                </code></pre>
                <p>
                Note it is no longer the middle of range (e.g. "mid" point), hence the name "split". For a proof, see my <a href="https://codeforces.com/blog/entry/112755">codeforces blog</a>.
                </p>
                <p>We can code segment trees like:</p>
                <details>
                    <summary>code</summary>
                    <pre><code class="language-cpp">
int split(int tl, int tr) {
    int pow_2 = 1 << __lg(tr-tl);
    return min(tl+pow_2, tr-pow_2/2);
}

const int MAXN = 500'000;
int n;
long long t[2*MAXN-1];

void build(int a[], int tl=0, int tr=n, int v=0) {
    if (tr - tl == 1) {
        t[v] = a[tl];
    } else {
        int tm = split(tl, tr);
        build(a, tl, tm, 2*v+1);
        build(a, tm, tr, 2*v+2);
        t[v] = t[2*v+1] + t[2*v+2];
    }
}

long long query(int l, int r, int tl=0, int tr=n, int v=0) {
    if (r <= tl || tr <= l) return 0LL;
    if (l <= tl && tr <= r) return t[v];
    int tm = split(tl, tr);
    return query(l, r, tl, tm, 2*v+1)
         + query(l, r, tm, tr, 2*v+2);
}

void update(int pos, int val, int tl=0, int tr=n, int v=0) {
    if (tr - tl == 1) {
        t[v] += val;
    } else {
        int tm = split(tl, tr);
        if (pos < tm)
            update(pos, val, tl, tm, 2*v+1);
        else
            update(pos, val, tm, tr, 2*v+2);
        t[v] = t[2*v+1] + t[2*v+2];
    }
}
                    </code></pre>
                </details>
                <h3>In Order</h3>
                <p>First, the <a href="https://codeforces.com/blog/entry/112755#comment-1004569">source</a> for the idea for this approach. An example of indexing the in-order of a full binary tree
                <code>0,1,2,...</code></p>
                <img src="bst_inorder.png" alt="bst in order" style="width:540px;height:auto;">
                <p>
                Observations:
                </p>
                <ul>
                    <li>BST-property: for every node <code>v</code>:
                        <ul>
                            <li>All nodes in <code>v</code>'s left subtree have index <code>&lt;v</code></li>
                            <li>All nodes in <code>v</code>'s right subtree have index <code>&gt;v</code></li>
                        </ul>
                    </li>
                    <li>the total number of nodes is odd; leaves have even indexes; internal nodes have odd indexes (this is only true because it's full)
                        <details>
                            <summary>Proof by induction</summary>
                            <p>
                            Base case 1:
                            <br>
                            <img src="bst_base_case_1.png" alt="base case 1" style="width:60px;height:auto;">
                            <br>
                            Base case 2:
                            <br>
                            <img src="bst_base_case_2.png" alt="base case 2" style="width:200px;height:auto;">
                            <br>
                            Now assume T1, T2 are full binary trees. Imagine
                            creating a new full binary tree T by creating a new
                            root, and setting T1 as the root's left subtree, T2
                            as the root's right subtree.
                            </p>
                            <p>Denode <code>|T|</code> as the total number of
                            nodes in T. <code>|T| = 1+|T1|+|T2| = 1+odd+odd =
                                odd</code></p>
                            <p>The root's index = <code>|T1|</code> = odd</p>
                            <p>The indexes of nodes in T1 doesn't change.</p>
                            <p>The indexes of nodes in T2 each increase by <code>1+|T1|</code> = 1+odd = even, so their parody doesn't change.</p>
                        </details>
                    </li>
                </ul>
                <hr>
                <p>
                Let's look at the same tree, with ranges and midpoints
                included. What can you observe about the midpoints?
                </p>
                <img src="bst_midpoints.png" alt="bst midpoints" style="width:540px;height:auto;">
                <p>
                Observations:
                </p>
                <ul>
                    <li>the set of <code>n-1</code> midpoints (<code>tm</code>) are distinct, and lie in <code>[1, n-1]</code></li>
                    <li>
                        BST-property for midpoints: for an internal node <code>v</code> with midpoint <code>tm</code>:
                        <ul>
                            <li>All internal nodes in <code>v</code>'s left subtree have midpoint <code>&lt;tm</code></li>
                            <li>All internal nodes in <code>v</code>'s right subtree have midpoint <code>&gt;tm</code></li>
                        </ul>
                    </li>
                </ul>
                <p>So we have to map the midpoints in <code>[1, n-1]</code> to odd indexes in <code>[0,2*n-2]</code> with the function <code>f(midpoint) = 2*midpoint-1</code> = in-order index</p>
                <p>Leaves each have range <code>[tl, tl+1)</code> which we can map to an even index <code>2*tl</code>. So we can write a function like:</p>
                <pre><code class="language-cpp">
int in_order(int tl, int tr) {
    return tr-tl > 1 ? (tl+tr)/2*2-1 : 2*tl;
}
                </code></pre>
                <p>And we can code segment trees like:</p>
                <details>
                    <summary>code</summary>
                    <pre><code class="language-cpp">
int in_order(int tl, int tr) {
    return tr-tl > 1 ? (tl+tr)/2*2-1 : 2*tl;
}

const int MAXN = 500'000;
int n;
long long t[2*MAXN-1];

void build(int a[], int tl=0, int tr=n) {
    if (tr - tl == 1) {
        t[in_order(tl,tr)] = a[tl];
    } else {
        int tm = (tl+tr)/2;
        build(a, tl, tm);
        build(a, tm, tr);
        t[in_order(tl,tr)] = t[in_order(tl,tm)] + t[in_order(tm,tr)];
    }
}

long long query(int l, int r, int tl=0, int tr=n) {
    if (r <= tl || tr <= l) return 0LL;
    if (l <= tl && tr <= r) return t[in_order(tl,tr)];
    int tm = (tl+tr)/2;
    return query(l, r, tl, tm)
         + query(l, r, tm, tr);
}

void update(int pos, int val, int tl=0, int tr=n) {
    if (tr - tl == 1) {
        t[in_order(tl,tr)] += val;
    } else {
        int tm = (tl+tr)/2;
        if (pos < tm)
            update(pos, val, tl, tm);
        else
            update(pos, val, tm, tr);
        t[in_order(tl,tr)] = t[in_order(tl,tm)] + t[in_order(tm,tr)];
    }
}
                    </code></pre>
                </details>
            </div>
        </div>
    </body>
</html>
